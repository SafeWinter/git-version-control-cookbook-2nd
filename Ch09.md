# 第九章 Git 仓库的运维

本章将介绍用于 `Git` 仓库运维工作的各类工具。例如在本地轻松删除远程库中已经删除的分支；垃圾回收的触发及关闭；利用 `filter-branch` 拆分 `Git` 仓库或修改仓库历史；最后简要介绍一下怎样以子项目的方式（应用子模块或子树策略），将 `Git` 库集成到另一个 `Git` 库。

本章相关主题：

- 整理远程仓库
- 手动执行垃圾回收
- 关闭自动垃圾回收
- 分隔仓库
- 重写提交历史 – 变更单个文件
- 以镜像的方式创建仓库备份
- 一个快捷子模块操作演示
- 子树合并
- 子模块与子树对比

---



## 9.1 整理远程仓库

项目的开发往往是在 `features` 特性分支上进行的。开发完成后并入主分支，并将原特性分支删除。对于不是推送该分支的本地库，`Git` 不会自动将分支变更信息自动更新到之前克隆的其他本地仓库，对这些本地仓库而言，必须手动同步远程分支信息。

使用命令：`git fetch --prune`

功能演示：

```bash
# Prepare repos: a bare and a clone
$ git clone --bare https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_hello_world_flow_model.git hello_world_flow_model_remote
$ git clone hello_world_flow_model_remote hello_world_flow_model
# delete branches from the remote repo
$ cd hello_world_flow_model_remote 
$ git branch -D feature/continents  
Deleted branch feature/continents (was 5bd5222).
$ git branch -D feature/printing  
Deleted branch feature/printing (was a5da07d).
$ git branch -D release/1.0  
Deleted branch release/1.0 (was 134fe4b).
# enter cloned repo
$ cd ../hello_world_flow_model 
$ git checkout develop 
$ git reset --hard origin/develop
# Check branches from remote
$ git branch -a 
* develop
  master
  remotes/origin/HEAD -> origin/master
  remotes/origin/develop
  remotes/origin/feature/cities
  remotes/origin/feature/continents
  remotes/origin/feature/printing
  remotes/origin/master
  remotes/origin/release/1.0
# fetch with default options
$ git fetch 
$ git pull 
Already up to date. 
$ git branch -a 
* develop
  master
  remotes/origin/HEAD -> origin/master
  remotes/origin/develop
  remotes/origin/feature/cities
  remotes/origin/feature/continents
  remotes/origin/feature/printing
  remotes/origin/master
  remotes/origin/release/1.0
# Sync with remote repo by using --prune
$ git fetch --prune
From C:/Users/ad/Desktop/hello_world_flow_model_remote
 - [deleted]         (none)     -> origin/feature/continents
 - [deleted]         (none)     -> origin/feature/printing
 - [deleted]         (none)     -> origin/release/1.0
# Check again
$ git branch -a
* develop
  master
  remotes/origin/HEAD -> origin/master
  remotes/origin/develop
  remotes/origin/feature/cities
  remotes/origin/master
```

此外，也可以用 `git pull --prune` 达到相同效果，或者运行命令 `git remote prune origin`。不过，后者虽然能够删除远程库中已经不存在的分支，但不会自动更新本地的远程跟踪分支信息。



## 9.2 手动执行垃圾回收

周期性运作 `git` 仓库时，有时可能会看到某些命令触发了 git 的垃圾回收，同时将松散对象变为致密文件（git 的对象式存储）。这也可以通过手动运行命令 `git gc` 实现。手动触发垃圾回收，可用于存在大量松散对象的场合。一个松散对象（`loose object`）可以是一个 `blob`、一个 `tree`、或者一个 `commit`。正如第一章中提到过的，这些对象是在添加到 `Git` 或创建版本时进入 `Git` 数据库的。这些对象最早以单个文件形式存放在 `.git/objects` 中（不可直接访问），然后通过事件或手动触发的方式打包为压缩文件以减少磁盘占用。当开启一个新项目并添加大量文件到 `git` 库时，会产生大量的松散对象。这时执行垃圾回收可以确保松散对象被压缩打包，同时未引用对象会被清除。后者尤其适用于本地删除了某些分支或版本、并希望引用它们的对象也一并清理的场景。

功能演示：

```bash
# Prepare repo
$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_hello_world_flow_model.git  
$ cd hello_world_flow_model 
$ git checkout develop 
$ git reset --hard origin/develop 
$ git count-objects
0 objects, 0 kilobytes
$ git fsck --unreachable 
Checking object directories: 100% (256/256), done.
Checking objects: 100% (58/58), done.
$  du -sh .git
56K     .git
$ git remote rm origin 
$  git fsck --unreachable
Checking object directories: 100% (256/256), done.
Checking objects: 100% (58/58), done.
unreachable commit 85d110c5bbe00733ad0f5404d7b88ef320217808
unreachable blob e26174ff5c0a3436454d0833f921943f0fc78070
unreachable tree f03964e50809d5a0a9d35c208001b141ac36d997
$ git gc
Enumerating objects: 55, done.
Counting objects: 100% (55/55), done.
Delta compression using up to 16 threads
Compressing objects: 100% (38/38), done.
Writing objects: 100% (55/55), done.
Total 55 (delta 20), reused 48 (delta 15), pack-reused 0
$ git count-objects
3 objects, 1 kilobytes
$ git fsck --unreachable
Checking object directories: 100% (256/256), done.
Checking objects: 100% (55/55), done.
unreachable commit 85d110c5bbe00733ad0f5404d7b88ef320217808
unreachable blob e26174ff5c0a3436454d0833f921943f0fc78070
unreachable tree f03964e50809d5a0a9d35c208001b141ac36d997
Verifying commits in commit graph: 100% (19/19), done.
$ du -sh .git
60K     .git
# before
$ git count-objects
3 objects, 4 kilobytes
$ git gc --prune=now
Enumerating objects: 55, done.
Counting objects: 100% (55/55), done.
Delta compression using up to 16 threads
Compressing objects: 100% (33/33), done.
Writing objects: 100% (55/55), done.
Total 55 (delta 20), reused 55 (delta 20)
# after
$ git count-objects
0 objects, 0 kilobytes
$ git fsck --unreachable
Checking object directories: 100% (256/256), done.
Checking objects: 100% (55/55), done.
$ du -sh .git
56K     .git
```

可以看到，不可及对象已被删除，且不存在松散对象，仓库大小重新还原。

> **原理剖析**

`git gc` 命令通过压缩修订文件、删除未被引用对象等实现了对 `git` 库的优化。在被废弃（已删除）的分支上，通过 `git add` 调用的 `blob`、通过 `git commit --amend` 或其他命令丢弃、撤回的提交或其他命令可能会留下对象。

默认情况下，对象在创建时已经用 `zlib` 进行了压缩，并且当移动到包文件中时，`Git` 确保只存储必要的更改。例如，如果在一个大文件中只更改一行，那么将整个文件再次存到包文件中会浪费一些空间。实际情况是，`Git` 将最新文件作为一个 `整体` 存储在包文件中，并且仅存储旧版本的变更增量。这样的设计非常巧妙，因为最新的文件更有可能被用到，而 `Git` 不必为此进行增量计算。这似乎与第一章中的相关论述相矛盾。当时提到，`Git` 存储快照而不是增量。但回忆一下快照是怎么来的就清楚了。 `Git` 对 `blob` 中的所有文件内容进行哈希散列，生成 `tree` 和 `commit` 对象；`commit` 对象使用根节点树的 `sha-1` 散列值描述完整的树状态。将对象存储在包文件中对树状态的计算 **没有影响**。签出较早版本时，`Git` 会确保 `sha-1` 哈希值与请求的分支、提交或标签相匹配。





## 9.3 关闭自动垃圾回收

垃圾回收的自动触发可以设置为关闭，需要是再手动执行。这样在查询丢失版本时，就不会受到自动回收的影响。

要禁用自动垃圾回收，需要设置 `gc.auto` 为 `0`：

```bash
# (on Linux) Query the default value
$ git config gc.auto
$ echo $?
1
# disable auto gc
$ git config gc.auto 0 
$ git config gc.auto 
0
# test gc automatically (disabled)
$ git gc --auto
# manually invoke gc
$ git ac
```





## 9.4 分隔仓库
## 9.5 重写提交历史 – 变更单个文件
## 9.6 以镜像的方式创建仓库备份
## 9.7 一个快捷子模块操作演示
## 9.8 子树合并
## 9.9 子模块与子树对比















