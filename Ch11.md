# 第十一章 Git 操作技巧与诀窍

本章相关主题：

- 活用 `git stash`
- 保存并应用 `stash`
- 用 `git bisect` 进行调试
- 使用 `git blame` 命令
- 设置彩色命令行界面
- 自动补全
- 让 Bash 自带状态信息
- 更多别名
- 交互式新增提交
- 用 Git 的图形界面交互式新增
- 忽略文件
- 展示与清理忽略文件

---



## 简介

本章将重点梳理 Git 的使用技巧，以便用于日常工作。例如在执行重要任务时被临时打断需要寄存工作区变更内容，或者使用 `bisect` 与 `blame` 命令高效定位 `bug`，抑或是设置命令行的颜色与状态信息等。此外还将进一步梳理实用别名、根据指定的行级变更创建更清爽的 `commit` 提交、以及忽略文件的相关操作。



## 11.1 活用 `git stash`

本节演示如何使用 `git stash` 命令来快速寄存未提交的更改并再次读取这些内容。该操作在某项重要任务被临时打断（如紧急修复线上 `bug`）时非常实用，可以快速保存本地更改，恢复当前工作区；待临时任务结束后再还原之前的工作状态。利用 `git stash` 命令，还可以在寄存本地更改时设置是否保存暂存区（`staging area`）中的内容。

相关命令：

- `git stash`：添加到寄存区（入栈）
- `git stash list`：查看寄存区的存放列表
- `git stash pop`：取回寄存区的内容（出栈）

实操示例如下：

```bash
# repo init
$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks.git tiptrick
$ cd tiptrick
$ git checkout master
# do some changes
$ echo "Just another unfinished line" >> foo
$ git add foo
$ echo "Another line" >> bar
$ echo "Some content" > new_file
$ git status -s
```

![git status -s](assets/c11-1.png)

可见，`git stash` 只对暂存区及加入版本管理的文件生效（`new_file` 未被寄存）。

```bash
# using git stash
$ git stash
Saved working directory and index state WIP on master: b6dabd7 Update foo and bar
$ git status -s
?? new_file
```

查看 `gitk`：

```bash
$ gitk master stash
```

结果如下：

 ![gitk stash result](assets/c11-2.png)
**图 11-1 放入寄存区后的分支状态** <a id="fig11_1"></a> [返回](#ref11_1) 

对 `foo` 文件作如下修改：

```bash
# on Linux (BSD sed)
$ sed -i 's/First line/This is the very first line of the foo file/' foo
$ git add foo
$ git commit -m "Update foo"
[master 3646ef9] Update foo
 1 file changed, 1 insertion(+), 1 deletion(-)
# check stashed contents
$ git stash list
stash@{0}: WIP on master: b6dabd7 Update foo and bar
```

实测发现，`Ubuntu` 环境下 `sed` 命令为 `sed -i 's/.../.../' foo`。

此时再查看分支状态：

```bash
$ gitk --reflog
```

结果如下：

![result for gitk --reflog](assets/c11-3.png)
**图 11-2 完成临时任务并提交后的分支状态** <a id="fig11_2"></a> [返回](#ref11_2)

完成临时任务后，取回 `stash` 命令寄存的内容如下：

```bash
$ git status -s
?? new_file
$ git stash pop
Auto-merging foo
On branch master
Your branch is ahead of 'origin/master' by 1 commit.
  (use "git push" to publish your local commits)

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   bar
        modified:   foo

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        new_file

no changes added to commit (use "git add" and/or "git commit -a")
Dropped refs/stash@{0} (c008d2f149d0827cbc06879b3097bd690128e260)
```

值得注意的是，虽然原来暂存区的变更也一并存入了寄存区，但还原时 `git` 默认只把工作区内的变更还原了。



> **原理分析**

上述演示中，`foo` 文件的一处修改先放到了寄存区；然后在处理临时任务时，对该文件的另一处内容作了修改并提交；之后再将寄存的变更重新还原到 `foo` 上，由于没有版本冲突，`Git` 作了自动合并。

根据 [图 11-1](#fig11_1)<a id="ref11_1"></a> 可知，加入寄存区后，`Git` 分别为索引区（`index`）及工作区（`work area`）创建了 `commit` 节点；这在临时任务提交后也可以佐证，如 [图 11-2](#fig11_2)<a id="ref11_2"></a> 所示。

`stash` 创建的 `commit` 对象存放在 `refs/stash` 命名空间下。其中，包含原暂存区信息的 `commit` 节点，称为 `index on master`（主分支上的索引信息）；另一个包含工作区信息的节点，叫 `WIP on master`（主分支上正在进行中的工作信息，`WIP` 是 `W`ork `I`n `P`rogress 的缩写）。这些临时创建的节点信息，可以通过 `git` 的常规操作将更改重新还原到工作目录下。也就是说，一旦还原过程中发生版本冲突，也可以通过 `git` 处理冲突的常规流程进行处理。



> **知识拓展**

通过刚才的演示得知，默认情况下，`git` 寄存或还原当前工作状态时，存在两个问题：

- 未加入版本控制的文件不会自动 `stash` 到寄存区；
- 还原只对工作区生效，尽管寄存了原暂存区的变更；

这两个问题都可以通过手动指定参数来解决。前者使用 `git stash --include-untracked` 解决；后者通过 `git stash pop --index` 解决：

```bash
$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks.git tiptrick
$ cd .\tiptrick\
$ echo "Just another unfinished line" >> foo; git add foo; echo "Another line" >> bar;echo "Some content" > new_file;
$ git stash --include-untracked
Saved working directory and index state WIP on master: b6dabd7 Update foo and bar
# Check untracked file (not existed):
$ git status -s
# Check gitk with 'stash' branch
$ gitk stash
```

查看结果如下：（`Git` 在 `stash` 上又新增一个节点来单独存放 **不在版本控制内的** 内容变更）

![git stash --include-untracked](assets/c11-4.png)

继续后面的操作，处理并提交临时任务，只是在还原寄存区的变更时，将原暂存区的变更也还原：

```bash
$ sed -i 's/First line/This is the very first line of the foo file/' foo
$ git add foo; git commit -m 'Update foo';
$ gitk --reflog
```

再次查看还原前的分支状态：

![new version of gitk --reflog](assets/c11-5.png)

这时，需要将原暂存区的变更内容一并还原到之前的状态：

```bash
$ git stash pop --index
$ git status -s
 M bar
M  foo
?? new_file
$ 
```

![result for git stash pop --index](assets/c11-6.png)

注意对比之前没加 `--index` 的输出内容。再次查看 `gitk --reflog` 予以验证，可以看到还原后的状态中，暂存区不同了：

![gitk --](assets/c11-7.png)

此外，还可以在放入寄存区时，手动指定是否需要保留暂存区的变更：在执行 `git stash` 时通过标记 `--keep-index` 实现（也可以加 `--include-untracked` 包含不受版本控制的变更）：

```bash
$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks.git tiptrick
$ cd .\tiptrick\
$ echo "Just another unfinished line" >> foo; git add foo; echo "Another line" >> bar;echo "Some content" > new_file
# keep changes in staging area 
# while stashing away untracked changes, too:
$ git stash --keep-index --include-untracked
Saved working directory and index state WIP on master: b6dabd7 Update foo and bar
# Check result (as expected)
$ git status
On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   foo

```



## 11.2 保存并应用 `stash`

寄存当前工作状态时，寄存区可能会有出现寄存状态，而默认的名称并不能区分要恢复的版本具体是哪个。本节将对这种情况进行处理，演示怎样给寄存区的存放记录命名，并恢复指定的版本：

```bash
# init repo
$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks.git tiptrick
$ cd .\tiptrick\
$ echo "Just another unfinished line" >> foo; git add foo; echo "Another line" >> bar;echo "Some content" > new_file
$ git stash --keep-index --include-untracked
Saved working directory and index state WIP on master: b6dabd7 Update foo and bar
$ git status
On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   foo
$ git stash list
stash@{0}: WIP on master: b6dabd7 Update foo and bar
# create stash and name the stash item
$ git stash save 'Updates to foo'
Saved working directory and index state On master: Updates to foo
$ git stash list
stash@{0}: On master: Updates to foo
stash@{1}: WIP on master: b6dabd7 Update foo and bar
# Create a new stash by changing bar:
$ echo "Another change" >> bar
$ git stash save 'Made another change to bar'
Saved working directory and index state On master: Made another change to bar
# check stash list
$ git stash list
stash@{0}: On master: Made another change to bar
stash@{1}: On master: Updates to foo
stash@{2}: WIP on master: b6dabd7 Update foo and bar
```

解决了寄存记录的命名问题，就可以在应用寄存信息的同时保留该记录：

```bash
# apply stash info
$ git stash apply 'stash@{1}'
# use --quiet to suppresses the status output
$ git stash apply --quiet 'stash@{0}'
$ git stash list
stash@{0}: On master: Made another change to bar
stash@{1}: On master: Updates to foo
stash@{2}: WIP on master: b6dabd7 Update foo and bar
```

可以看到，寄存列表在成功还原后仍在存在。应用某个寄存区的记录，语法为：`git stash apply stash@{stash-no}`。



> **发散**

寄存列表如何删除呢？执行命令 `git stash drop stash@{stash-no}` 即可：

```bash
$ git stash list
stash@{0}: On master: Made another change to bar
stash@{1}: On master: Updates to foo
stash@{2}: WIP on master: b6dabd7 Update foo and bar
$ git stash drop 'stash@{1}'
Dropped stash@{1} (ef0c0e7de00803e61f7a2a02df581bedb143778b)
$ git stash list
stash@{0}: On master: Made another change to bar
stash@{1}: WIP on master: b6dabd7 Update foo and bar
```

对比之前的默认版本，手动应用或删除寄存区版本提供了更多的灵活性，可以避免一个操作失误。默认情况下，成功 `stash pop` 一个版本后，该版本会从寄存区自动删除；但若还原过程受阻（如发生冲突）则会被保留下来，即便用户处理了这个冲突，寄存区的版本仍不会自动删除。这就为后续的版本还原埋下了隐患。而手动控制应用或删除，就可以很好地解决这个问题。



> **小试牛刀**

`git stash` 命令也能把调式信息应用到项目中。比如在调式代码过程中，为了定位 `bug` 而在项目中加入了不少调式用的语句，调试结束后不必手动删除所有的调试语句。相反，可以将这些语句通过 `git stash save "Debug info stash"` 寄存到 `git` 中并命名。这样在今后再次调试时，可以应用该寄存版快速初始化上一次的调试环境。





## 11.3 用 `git bisect` 进行调试

实际工作中经常遇到类似“究竟是哪次提交引入的某个 `Bug`”的问题，而底层应用二分算法的 `git bisect` 命令是该类问题的绝佳工具，尤其适用于在较长的提交历史记录中快速锁定引入 `bug` 具体 `commit`。二分查找法（`binary search method`）或二分法（`bisection method`），是一种在有序数组中查找目标位置的搜索方法。算法会在每一步与数组的中间值进行比较，如果匹配成功则返回该位置；否则，根据比较结果，选择中间值的右侧或左侧的子数组继续搜索，直至找到目标位置。在 `Git` 中，历史提交记录对应一组可供测试的值数组，若程序能在某个 `commit` 编译成功则为目标位置。二分查找的算法复杂度为 ***O(log n)***。

本节演示如何从一个提交了 23 次的带 `bug` 分支利用 `git bisect` 命令定位该 `bug` 的全过程（假设带 `bug` 提交的 `SHA-1` 为 `83c22a39955ec10ac1a2a5e7e69fe7ca354129af`）：

```bash
# init repo
$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks.git bugHunting
$ cd bugHunting
$ git checkout bug_hunting
```

该 `bug` 位于 `map.txt` 文件第 38 行：

![file with a bug](assets/c11-8.png)

接下来是找到检测该 `bug` 的方法来测试不同版本。比如编译代码，执行测试等等。这里简化为定位代码中是否存在 `oo` 字样的行，编写测试脚本 `test.sh` 如下：（注：该测试脚本只适用于 `Linux` 环境下）

```bash
$ echo "! grep -q oo map.txt " > ../test.sh
$ chmod +x ../test.sh
```

为了避免测试脚本不受项目签出、编译等影响，最好将测试脚本放到 `git` 库外面。

> **小提示**
>
> 经实测，测试脚本 `test.sh` 第一行末尾须加一个空格，否则脚本只能在 `Linux` 环境运行成功，而 `Windows` 下，`Windows` 的换行符号会与文件名 `test.sh` 连在一起，从而导致目标文件定位失败。

接下来开始测试：

```bash
$ git bisect start
# mark current commit as bad
$ git bisect bad
# mark the last known good commit (master HEAD) as good
$ git bisect good master
Bisecting: 12 revisions left to test after this (roughly 4 steps)
[7fb98059857aa0361cf14329d027573afd5a17b2] Build map part 10
# 1st round
$ ../test.sh; test $? -eq 0 && git bisect good || git bisect bad
Bisecting: 6 revisions left to test after this (roughly 3 steps)
[de6b768ceebd451591ee41ff4708ca889bafd3f2] Build map part 15
# 2nd round
$ ../test.sh; test $? -eq 0 && git bisect good || git bisect bad
Bisecting: 2 revisions left to test after this (roughly 2 steps)
[865ff6f8a62d61e4a59f7bc1b2478aa6c71c345a] Build map part 13
# 3rd round
$ ../test.sh; test $? -eq 0 && git bisect good || git bisect bad
Bisecting: 0 revisions left to test after this (roughly 1 step)
[27952d82d1f9067948b37e39b9bc4d0e6d846567] Build map part 14
# 4th round
$ ../test.sh; test $? -eq 0 && git bisect good || git bisect bad
Bisecting: 0 revisions left to test after this (roughly 0 steps)
[83076f97e8312f8d59976c6373c897aef284c26d] Bugs...
# 5th round
$ ../test.sh; test $? -eq 0 && git bisect good || git bisect bad
83076f97e8312f8d59976c6373c897aef284c26d is the first bad commit
commit 83076f97e8312f8d59976c6373c897aef284c26d
Author: HAL 9000 <aske.olsson@switch-gears.dk>
Date:   Tue May 13 09:53:45 2014 +0200

    Bugs...

 map.txt | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)
# reset bisect, get SHA-1 (83076f9): 
$ git bisect reset
Previous HEAD position was 83076f9 Bugs...
Switched to branch 'bug_hunting'
Your branch is up to date with 'origin/bug_hunting'.
$ git show 83076f9
commit 83076f97e8312f8d59976c6373c897aef284c26d
Author: HAL 9000 <aske.olsson@switch-gears.dk>
Date:   Tue May 13 09:53:45 2014 +0200

    Bugs...

diff --git a/map.txt b/map.txt
index 8a13f6b..1afeaaa 100644
--- a/map.txt
+++ b/map.txt
@@ -34,6 +34,6 @@ Australia:
                .-./     |.     :  :,
               /           '-._/     \_
              /                '       \
-           .'                         *: Brisbane
-        .-'                             ;
-        |                               |
+           .'        \__/             *: Brisbane
+        .-'          (oo)               ;
+        |           //||\\              |
```

演示过程的示意图如下：

![git bisect result](assets/c11-9.png)

其实倒数第二轮时已经找到引入 bug 的版本了，但需要进一步确认 bug 是该版本自己产生的，还是其他版本传播到这里的，因此多运行了一轮。



> **发散**

上述示例的一个弊端就是手动执行每一轮测试脚本，直到找出目标位置为止。若想让该过程自动进行，可以给 git 指定一个脚本（`script`），或 `makefile`，或一个测试脚本，使得二分查找自动进行。传入的脚本，会在命中目标时用返回一个为零状态（`exit with a zero-status`），或者在未命中时返回一个非零状态（`a non-zero status`）：

```bash
# Automatic bisect
$ git bisect start HEAD master
Bisecting: 12 revisions left to test after this (roughly 4 steps)
[7fb98059857aa0361cf14329d027573afd5a17b2] Build map part 10
# pass the test script
$ git bisect run ../test.sh
running  '../test.sh'
Bisecting: 6 revisions left to test after this (roughly 3 steps)
[de6b768ceebd451591ee41ff4708ca889bafd3f2] Build map part 15
running  '../test.sh'
Bisecting: 2 revisions left to test after this (roughly 2 steps)
[865ff6f8a62d61e4a59f7bc1b2478aa6c71c345a] Build map part 13
running  '../test.sh'
Bisecting: 0 revisions left to test after this (roughly 1 step)
[27952d82d1f9067948b37e39b9bc4d0e6d846567] Build map part 14
running  '../test.sh'
Bisecting: 0 revisions left to test after this (roughly 0 steps)
[83076f97e8312f8d59976c6373c897aef284c26d] Bugs...
running  '../test.sh'
83076f97e8312f8d59976c6373c897aef284c26d is the first bad commit
commit 83076f97e8312f8d59976c6373c897aef284c26d
Author: HAL 9000 <aske.olsson@switch-gears.dk>
Date:   Tue May 13 09:53:45 2014 +0200

    Bugs...

 map.txt | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)
bisect found first bad commit
$ git bisect reset
Previous HEAD position was 83076f9 Bugs...
Switched to branch 'bug_hunting'
Your branch is up to date with 'origin/bug_hunting'.
$ git show 83076f9
# ... (omitted)
```





## 11.4 使用 `git blame` 命令

上一节的 `git bisect` 适用于只知道项目有 `bug`，但不知道 `bug` 在哪儿、是具体哪次提交引入的场景。如果知道了 `bug` 在代码中的位置，需要明确谁提交或改动的这行代码，就需要使用 `git blame` 命令。

继续以 `Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks` 库为例：

```bash
$ git blame --date short -L 30,47 .\map.txt
7fb98059 (Dave Bowman      2014-05-13 30) Australia:
33016136 (Frank Poole      2014-05-13 31)
33016136 (Frank Poole      2014-05-13 32)                     _,__        .:
33016136 (Frank Poole      2014-05-13 33)             Darwin <*  /        | \
5a5f6ef7 (Frank Poole      2014-05-13 34)                .-./     |.     :  :,
5a5f6ef7 (Frank Poole      2014-05-13 35)               /           '-._/     \_
5a5f6ef7 (Frank Poole      2014-05-13 36)              /                '       \
83076f97 (HAL 9000         2014-05-13 37)            .'        \__/             *: Brisbane
83076f97 (HAL 9000         2014-05-13 38)         .-'          (oo)               ;
83076f97 (HAL 9000         2014-05-13 39)         |           //||\\              |
27952d82 (Dave Bowman      2014-05-13 40)         \                              /
27952d82 (Dave Bowman      2014-05-13 41)          |                            /
27952d82 (Dave Bowman      2014-05-13 42)    Perth  \*        __.--._          /
de6b768c (Heywood R. Floyd 2014-05-13 43)            \     _.'       \:.       |
de6b768c (Heywood R. Floyd 2014-05-13 44)            >__,-'             \_/*_.-'
de6b768c (Heywood R. Floyd 2014-05-13 45)                                  Melbourne
9b49c0f0 (Heywood R. Floyd 2014-05-13 46)         snd                     :--,
9b49c0f0 (Heywood R. Floyd 2014-05-13 47)                                  '/
```

其中的 `-L` 表示限定考察代码的行数范围，格式为 `-L <from>,<to>` 。从反馈的结果可知，`bug` 出现在 `map.txt` 文件的第 37 至 39 行，由 `HAL` 首次引入该 `bug`，对应 `SHA-1` 为 `83076f97`，与 `git bisect` 结果一致。

此外，还可以指定 `-M` 参数，查看文件被重构或移动到某处的情况；指定 `-C` 参数，则可以展示目标文件从当前 `commit` 包含的文件中复制或移入相关代码的情况；指定 `-CCC` 则范围不仅限于当前 `commit`，可包含所有 `commit`。





## 11.5 设置彩色命令行界面

默认的 git 命令行内容是黑白模式的，切换彩色模式只需一步简单配置：

```bash
$ git config --global color.ui true
```

设置生效前后效果对比演示：

```bash
$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks.git colorUI
$ cd colorUI
$ echo "And another line" >> foo
$ git add foo
$ echo "Last line ...so far" >> foo
$ touch test
# before configuration
$ git status
# set color UI
$ git config --global color.ui true
# check status by comparison
$ git status
```

配置前：

![before color UI](assets/c11-10.png)

配置后：

![after color UI](assets/c11-11.png)

彩色输出结果对多种 `git` 命令生效，如 `diff`、`log`、`branch` 等：

```bash
$ git log --oneline --decorate --graph
```

![colored git log](assets/c11-12.png)





## 11.6 自动补全

`git` 自动补全，是指键入 <kbd>Tab</kbd> 键自动补全相关命令或参数项。通常在安装 `git` 时自带该功能。关键是将自动补全配置文件 `git-completion.bash` 放入指定路径：

|     操作系统      |                  `git-completion.bash` 路径                  |
| :---------------: | :----------------------------------------------------------: |
|       Linux       |                 `/etc/bash_completion.d/` 下                 |
|       MacOS       | `/Library/Developer/CommandLineTools/usr/share/git-core/` 下 |
| Mac from Homebrew | `/usr/local/Cellar/git/2.15.0/etc/bash_completion.d/git-completion.bash` |
|      Windows      |          `%GIT_HOME%\mingw64\share\git\completion`           |

如果文件缺失，可从 `GitHub` 下载：https://github.com/git/git/blob/master/contrib/completion/git-completion.bash

激活配置脚本：

```bash
# take Linux for instance
if [ -f /etc/bash_completion.d/git-completion.bash ]; then
    source /etc/bash_completion.d/git-completion.bash
fi
```

自动补全不仅对命令生效（如 `git che<tab><tab>`），还可以用于提示命令参数：（如 `git branch --<tab><tab>`）：

![autocomletion](assets/c11-13.png)





## 11.7 让 Bash 自带状态信息

本节示例需在 `Linux` 环境运行：

```bash
root@SinosoftE14-Zad:/mnt/c/Users/z/Desktop/colorUI# echo $PS1
\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\u@\h:\w\$
# \u: user
# \h:hostname
# \w:the current working directory relative to the user's home directory

# add a branch name after the working directory
root@SinosoftE14-Zad:/mnt/c/Users/z/Desktop/colorUI# PS1='\u@\h:\w$(__git_ps1 " (%s)") \$ '
root@SinosoftE14-Zad:/mnt/c/Users/z/Desktop/colorUI (master) # pwd
/mnt/c/Users/z/Desktop/colorUI
root@SinosoftE14-Zad:/mnt/c/Users/z/Desktop/colorUI (master) #
```

由于当前目录在上一节的 `git` 库 `master` 分支，因此命令行的提示符多了 `(master)` 字样。

其他可供配置的环境变量：

|         **Variable**         |            **Value**             | **Effect**                                                   |
| :--------------------------: | :------------------------------: | ------------------------------------------------------------ |
|   `GIT_PS1_SHOWDIRTYSTATE`   |             Nonempty             | Shows `*` for unstaged changes and `+` for staged changes.   |
|   `GIT_PS1_SHOWSTASHSTATE`   |             Nonempty             | Shows the `$` character if something is stashed.             |
| `GIT_PS1_SHOWUNTRACKEDFILES` |             Nonempty             | Shows the `%` character if there are untracked files in the repository. |
|    `GIT_PS1_SHOWUPSTREAM`    | auto verbose name legacy Git svn | Auto shows whether you are behind (`<`) or ahead (`>`) of the upstream branch. A `<>` value is displayed if the branch is diverged and `=` if it is up to date. Verbose shows the number of commits behind/ahead. Name shows the upstream name. Legacy is verbose for old versions of Git. Git compares `HEAD` to `@{upstream}`. SVN compares `HEAD` to `svn upstream`. |
|   `GIT_PS1_DESCRIBE_STYLE`   | contains branch describe default | Displays extra information when on a detached `HEAD`. Contains is relative to a newer annotated tag (`v1.6.3.2~35`). Branch is relative to a newer tag or branch (`master~4`). Describe is relative to an older annotated tag (`v1.6.3.1-13-gdd42c2f`). Default is the tag that matches exactly. |

由于 `Windows` 版 `Git` 已配置了 `oh-my-posh` 主题样式，故 `Windows` 不考虑按本书定制命令行。

在 `~/.bashrc` 设置如下内容：

```bash
export GIT_PS1_SHOWUPSTREAM=auto
export GIT_PS1_SHOWDIRTYSTATE=enabled
PS1='u@h:w$(__git_ps1 " (%s)") $ '
```

测试效果：

```bash
$ cd bugHunting
$ touch test
$ git add test
$ echo "Testing" > test
$ git commit -m 'test'
```

![config prompt 1](assets/c11-14.png)

有了定制化的配置项 `__git_ps1`，合并、变基、二分查找相关命令都会在命令行中通过符号予以实时展示，`git status` 命令瞬间黯然失色。



> **发散：设置彩色命令行**

现如今不支持彩色显示的命令行还叫命令行吗？在 `~/.bashrc` 加入如下配置项：

```bash
export GIT_PS1_SHOWUPSTREAM=auto
export GIT_PS1_SHOWDIRTYSTATE=enabled
export GIT_PS1_SHOWCOLORHINTS=enabled
PROMPT_COMMAND='__git_ps1 "\u@\h:\w" "\$ "'
```

看看效果：

![config prompt 2](assets/c11-15.png)





## 11.8 更多别名
## 11.9 交互式新增提交
## 11.10 用 Git 的图形界面交互式新增
## 11.11 忽略文件
## 11.12 展示与清理忽略文件
